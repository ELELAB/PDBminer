#!/usr/bin/env python3

# Copyright (C) 2022, Kristine Degn
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import argparse
import pandas as pd
from sys import exit
import requests
from requests.exceptions import ConnectionError
from datetime import datetime

parser = argparse.ArgumentParser(prog = "PDBminer",
                                 usage = 'PDBminer [-h] help [-n] cores and then either [-i] input file, or [-g] hugo_name and [-u] uniprot id')

parser.add_argument("-i", '--inputfile',
                    metavar = 'input file',
                    type=str,
                    help='The name of the input_file if any')

parser.add_argument("-g", '--hugo_name',
                    metavar = 'hugo name',
                    type=str,
                    help='The gene name in hugo formating')

parser.add_argument("-u", '--uniprot_id',
                    metavar = 'uniprot_id',
                    type=str,
                    help='The uniprot id')

parser.add_argument("-s", '--uniprot_isoform',
                    metavar = 'uniprot_isoform',
                    type=int,
                    help='The uniprot isoform, an interger')

parser.add_argument("-m", '--mutations',
                    metavar = 'mutations',
                    type=str,
                    help='string with each mutation seperated by a ";" with "" around the expression, e.i. "E120K;I390P"')

parser.add_argument("-c", '--cluster_id',
                    metavar = 'cluster id',
                    type=int,
                    help='The mutational cluster, an interger')

parser.add_argument("-n", "--cores",
                    metavar = "cores for run",
                    type=int,
                    default = 1,
                    help="the number of cores to allocate the run, if nothing is choosen: 1 core")

parser.add_argument("-f", "--snakefile",
                    metavar = "snakefile placement",
                    type=str,
                    default = "/usr/local/envs/PDBminer/PDBminer/program/snakefile",
                    help="snakefile path")


args = parser.parse_args()
path = os.getcwd()

def check_APIs():
    
    checked_api = []
    #check uniprot fasta, use p53 as test case
      
    uniprot_url = "https://www.uniprot.org/uniprot/P04637.txt"
    try: 
        response = requests.get(uniprot_url)  
    except ConnectionError as e:
        checked_api.append("UNIPROT API controlled and rejected, connection error\n")
    
    #check PDBe, use 2XWR as test case
    
    mapping_url = "https://www.ebi.ac.uk/pdbe/api/pdb/entry/summary/2XWR"
    try: 
        response = requests.get(mapping_url)
    except ConnectionError as e:
        checked_api.append("PDBe API controlled and rejected, connection error\n")
        
    beacons_url = "https://www.ebi.ac.uk/pdbe/pdbe-kb/3dbeacons/api/uniprot/P04637.json?provider=pdbe"
    try: 
        response = requests.get(mapping_url)
    except ConnectionError as e:
        checked_api.append("3D beacons API controlled and rejected, connection error\n")

    return checked_api

def check_input_file(df):

    df = df.fillna("N/A")

    problems = []
    
    for i in range(len(df)):
        if type(df.hugo_name[i]) != str:
            problems.append(f"there is a problem with the input on the line of {df.loc[i]['hugo_name']}")
        if type(df.uniprot[i]) != str:
            problems.append(f"there is a problem with the uniprot input on the line of {df.loc[i]['hugo_name']}")
        
        if ('uniprot_isoform' in df.columns) == True:
            try:
                int(df.uniprot_isoform[i])
            except ValueError:
                problems.append(f"there is a problem with the isoform input on the line of {df.loc[i]['hugo_name']}")
        else:
            uniprot_isoform = [1] * len(df) 
            df['uniprot_isoform'] = uniprot_isoform
        
        if ('mutations' in df.columns) == True:
            if type(df.mutations[i]) != str:
                problems.append(f"there is a problem with the mutation input on the line of {df.loc[i]['hugo_name']}")
        else:
            mutations = ['N/A'] * len(df)
            df['mutations'] = mutations
            
        if ('cluster_id' in df.columns) == True:
            if len(set(df.cluster_id)) == 1 and df.cluster_id[0] == "N/A":
                df.cluster_id = 999
            try:
                int(df.cluster_id[i])
            except ValueError:
                problems.append(f"there is a problem with the cluster_id input on the line of {df.loc[i]['hugo_name']}") 
        else: 
            cluster_id = [999] * len(df)
            df['cluster_id'] = cluster_id
    
    return df, problems

with open (f"{path}/log.txt", "w") as f:
    start = datetime.now()
    f.write("PDBminer is starting\n")

    if args.inputfile:
        input_file = args.inputfile
        f.write("input file mode is choosen and input file has been identified.\n")

        df = pd.read_csv(input_file)
        df,problems = check_input_file(df)

        if len(problems) == 0:
            df.to_csv(input_file, index=False)

        elif len(problems) > 0:
            f.write(f"ERROR: The input file is not correctly formated. {problems}. Exiting...\n")
            exit(1)
        else:
            f.write("input file is correctly formatted\n")

    elif args.hugo_name and args.uniprot_id:
        hugo_name = [args.hugo_name]
        uniprot_id = [args.uniprot_id]
        df = pd.DataFrame({'hugo_name':hugo_name,'uniprot':uniprot_id})
        if args.uniprot_isoform:
            isoform = [args.uniprot_isoform]
            df['uniprot_isoform'] = isoform
        else: df['uniprot_isoform'] = [1]
        if args.mutations:
            mutations = [args.mutations]
            df['mutations'] = mutations
        else: df['mutations'] = ["N/A"]
        if args.cluster_id:
            cluster = [args.cluster_id]
            df['cluster_id'] = cluster
        else: df['cluster_id'] = [999]
        df.to_csv(f'{path}/input_file.csv')
        input_file = 'input_file.csv'
        f.write("input file created based on hugo name and uniprot id, file name: input_file.csv\n")

    else:
        f.write("ERROR: input file or input hugo name and uniprot id is missing. Exiting...\n")
        exit(1)
        
    f.write("APIs are checked\n")
    api = check_APIs()
    if api == []:
        f.write("   APIs controlled and accepted\n")
    else:
        f.write(f"   ERROR: {api}")
        exit(1)

    f.write("Pipeline is starting\n")
    snake = datetime.now()
    os.system(f"snakemake --cores {args.cores} --snakefile {args.snakefile} --config input_file={input_file} path={path}")

    os.system(f"rm {path}/results/*/*done.txt")
    os.system(f"rm {path}/results/*/*input.csv")
    finished = datetime.now() 
    f.write(f"time: {finished-start}\n")
    f.write(f"before snakemake: {snake-start}\n")
    f.write("PDBminer has finished.\n")
