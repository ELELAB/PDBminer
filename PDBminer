#!/usr/bin/env python3

# Copyright (C) 2021-2023, Kristine Degn
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import argparse
import pandas as pd
from sys import exit
import requests
from requests.exceptions import ConnectionError
from datetime import datetime
import json

parser = argparse.ArgumentParser(prog = "PDBminer",
                                 usage = 'PDBminer [-h] help [-n] cores and then either [-i] input file, or [-g] hugo_name and [-u] uniprot id')

parser.add_argument("-i", '--inputfile',
                    metavar = 'input file',
                    type=str,
                    help='The name of the input_file if any')

parser.add_argument("-g", '--hugo_name',
                    metavar = 'hugo name',
                    type=str,
                    help='The gene name in hugo formating')

parser.add_argument("-u", '--uniprot_id',
                    metavar = 'uniprot_id',
                    type=str,
                    help='The uniprot id')

parser.add_argument("-s", '--uniprot_isoform',
                    metavar = 'uniprot_isoform',
                    type=int,
                    help='The uniprot isoform, an interger')

parser.add_argument("-m", '--mutations',
                    metavar = 'mutations',
                    type=str,
                    help='string with each mutation seperated by a ";" with "" around the expression, e.i. "E120K;I390P"')

parser.add_argument("-c", '--cluster_id',
                    metavar = 'cluster id',
                    type=int,
                    help='The mutational cluster, an interger')

parser.add_argument("-n", "--cores",
                    metavar = "cores for run",
                    type=int,
                    default = 1,
                    help="the number of cores to allocate the run, if nothing is choosen: 1 core")

parser.add_argument("-f", "--snakefile",
                    metavar = "snakefile placement",
                    type=str,
                    default = "/usr/local/envs/PDBminer/PDBminer/program/snakefile",
                    help="snakefile path")


args = parser.parse_args()
path = os.getcwd()

def uniprot_accession_number_type(df):
    """
    This function takes the input to PDBminer read as a pandas dataframe 
    and check if the uniprot accession numbers are correctly formatted.

    Parameters
    ----------
    df : The input dataframe generated from the input CSV.

    Returns
    -------
    problems : If the uniprot accession number is not a string, the format
    is wrong and will return a list of string(s) with the offending input.

    """
    problems = []
    
    #Uniprot Accession number check:
    problematic_uniprots = df.uniprot[~df.uniprot.apply(lambda x: isinstance(x, str))]
    for uniprot_value in problematic_uniprots:
        problems.append(f"there is a problem with the uniprot input: {uniprot_value}")
    
    # If there are issues with the uniprot input, the program should end, 
    # since this is the only mandatory element of the input.
    if problems != []:
        return problems
    
def retrieve_hugo_name(uniprot_accession_number):
    """
    This functon takes a uniprot accession number and retrieves a gene name
    from the uniprot database. If Uniprot DB is down, the program will
    end with an error.

    Parameters
    ----------
    uniprot_accession_number : Accession number. 

    Returns
    -------
    hugo_name : The listed gene name for the uniprot accession number.

    """
    
    #try to get the hugoname from the uniprot database. 
    # If the uniprot datbase is down, the program will exit.
    try: 
        response = requests.get(f"https://www.uniprot.org/uniprot/{uniprot_accession_number}.json")
    except ConnectionError as e:
        with open("log.txt", "a") as textfile:
            textfile.write(f"EXITING: Uniprot database API controlled and rejected for {uniprot_accession_number} when finding the Hugo Name, connection error.\n")
        exit(1)
    
    # If the response is successfull, hugo name is collected.
    if response.status_code == 200:
        uniprot_file_content = json.loads(response.text)
        hugo_name = uniprot_file_content['genes'][0]['geneName']['value']
    
    # Otherwise the field is left empty
    else: 
        hugo_name = "NA"
        with open("log.txt", "a") as textfile:
            textfile.write(f"WARNING: No Hugo Name could be retrived with UniProt for {uniprot_id}. Gene name assigned NA.\n")
        
    return hugo_name
    
    
def check_input_file(df):

    problems = []
    
    # The rest of the columns are optional and may be populated in this function.
    for i in range(len(df)):        
        
        #HUGO NAME
        if not 'hugo_name' in df.columns:
            hugo_name_specific = retrieve_hugo_name(df.uniprot[i])
            df.loc[i,"hugo_name"] = hugo_name_specific
                        
        else:
            if df.hugo_name[i] in ["N/A", "NA"] or pd.isna(df.hugo_name[i]):
                hugo_name_specific = retrieve_hugo_name(df.uniprot[i])
                df.loc[i,"hugo_name"] = hugo_name_specific
                
            if not isinstance(df.hugo_name[i], str):
                problems.append(f"there is a problem with the hugo name input on the line of {df.loc[i]['uniprot']}")
                
        #ISOFORM    
        if 'uniprot_isoform' in df.columns:
            if df.uniprot_isoform[i] == "N/A" or df.uniprot_isoform[i] == "NA" or pd.isna(df.uniprot_isoform[i]):
                df.loc[i,"uniprot_isoform"] = 1
            else:
                try:
                    int(df.uniprot_isoform[i])
                except ValueError:
                    problems.append(f"there is a problem with the isoform input on the line of {df.loc[i]['uniprot']}")
        else:
            df.loc[i,"uniprot_isoform"] = 1
        
        #MUTATIONS
        if 'mutations' in df.columns:
            if df.mutations[i] in ["N/A", "NA"] or pd.isna(df.mutations[i]):
                df.loc[i,"mutations"] = "NA"
            elif not isinstance(df.mutations[i], str):
                problems.append(f"there is a problem with the mutation input on the line of {df.loc[i]['uniprot']}")
        else:
            df.loc[i,"mutations"] = "N/A"
        
        #CLUSTER ID
        if 'cluster_id' in df.columns:
            if df.cluster_id[i] == "N/A" or df.cluster_id[i] == "NA" or pd.isna(df.cluster_id[i]):
                df.loc[i,"cluster_id"] = "NA"
            else:
                try:
                    int(df.cluster_id[i])
                except ValueError:
                    problems.append(f"there is a problem with the cluster_id input on the line of {df.loc[i]['uniprot']}") 
        else: 
            df.loc[i,"cluster_id"] = "NA"
        
    df = df[['hugo_name', 'uniprot', 'uniprot_isoform', 'mutations', 'cluster_id']]
    
    return df, problems

with open (f"{path}/log.txt", "w") as f:
    start = datetime.now()
    f.write("PDBminer is starting\n")

    if args.inputfile:
        input_file = args.inputfile
        f.write("input file mode is choosen and input file has been identified.\n")

        df = pd.read_csv(input_file)
        
        uniprot_problems = uniprot_accession_number_type(df)
        if uniprot_problems is not None:
            f.write(f"ERROR: The input file is not correctly formated. {uniprot_problems}. Exiting...\n")
            exit(1)
        
        df,problems = check_input_file(df)

        if problems == []:
            df.to_csv(input_file, index=False)

        elif len(problems) > 0:
            f.write(f"ERROR: The input file is not correctly formated. {problems}. Exiting...\n")
            exit(1)

    elif args.uniprot_id:
        uniprot_id = [args.uniprot_id]
        if args.hugo_name:
            hugo_name = [args.hugo_name]
        else:  
            hugo_name = retrieve_hugo_name(uniprot_id)
        
        df = pd.DataFrame({'hugo_name':hugo_name,'uniprot':uniprot_id})
        
        if args.uniprot_isoform:
            isoform = [args.uniprot_isoform]
            df['uniprot_isoform'] = isoform
        else: df['uniprot_isoform'] = [1]
        
        if args.mutations:
            mutations = [args.mutations]
            df['mutations'] = mutations
        else: df['mutations'] = ["NA"]
        
        if args.cluster_id:
            cluster = [args.cluster_id]
            df['cluster_id'] = cluster
        
        else: df['cluster_id'] = ["NA"]
        df.to_csv(f'{path}/input_file.csv')
        input_file = 'input_file.csv'
        f.write("input file created based on hugo name and uniprot id, file name: input_file.csv\n")

    else:
        f.write("ERROR: input file or input hugo name and uniprot id is missing. Exiting...\n")
        exit(1)
        
    f.write("Pipeline is starting\n")
    snake = datetime.now()
    os.system(f"snakemake --cores {args.cores} --snakefile {args.snakefile} --config input_file={input_file} path={path}")

    os.system(f"rm {path}/results/*/*done.txt")
    os.system(f"rm {path}/results/*/*input.csv")
    finished = datetime.now() 
    f.write(f"time: {finished-start}\n")
    f.write(f"before snakemake: {snake-start}\n")
    f.write("PDBminer has finished.\n")
